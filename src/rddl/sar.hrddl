domain sar {
  requirements = {
    reward-deterministic,
    integer-valued,
    task-hierarchy //allows for compound-tasks, methods block, etc.
  };

  pvariables {
    YELLOW-POINT-VALUE : {non-fluent, int, default = 50};
    GREEN-POINT-VALUE : {non-fluent, int, default = 10};
    YELLOW-DEATH-TIME : {non-fluent, int, default = 420};
    END-GAME-TIME : {non-fluent, int, default = 600};

    time : {state-fluent, int, default = 0};
    num_of_yellow_victims_found_in_adj_room : {state-fluent, int, default = 0};
    num_of_green_victims_found_in_adj_room : {state-fluent, int, default = 0};
    times_searched : {state-fluent, int, default = 0};
    num_of_yellow_victims_found_in_current_room : {state-fluent, int, default = 0}; 
    num_of_green_victims_found_in_current_room : {state-fluent, int, default = 0};
    num_of_yellow_victims_triaged_in_current_room : {state-fluent, int, default = 0}; 
    num_of_green_victims_triaged_in_current_room : {state-fluent, int, default = 0};

    search : {action-fluent, bool, default = false};
    triageGreen : {action-fluent, bool, default = false};
    triageYellow: {action-fluent, bool, default = false};
    move : {action-fluent, bool, default = false};
    exit : {action-fluent, bool, default = false};

    //compound-task can have up to 1 argument,specifically of type method. Can omit argument if only 1
    //method is intended without parameters. 
    YF(method) : {ct-fluent, bool, default = false};
    O(method) : {ct-fluent, bool, default = false}; 

    //parameters of type a and b are assigned to the method
    // A(method(a,b)) : {compound-task, bool, default = false};
  };

  methods { //methods block
    //methods must be defined in the form
    // if (compound-task(@method_name) logical_op value) then ((action = value/compound-task) ->
    // (action = value/compound-task) -> ...)

    //(a = value -> b = value) is a sequence of assignments

    //"if (A) ..." is equivalent to "if (A == true) ..." 
    if (YF(@search_YF)) then (search = 1 -> YF(?m)); 

    // else if and else are not permitted here

    //Method example with params
    //if (A(@a(?v))) then (a = 1 -> B(?m(?v))); 
    
    //concurrency only allowed for action-fluents

    //if (Y(@z)) then a = 1 ^ b = 1; //Do both a and b concurrently

    //if (Y(@z)) then a = 1 <-> b = 1; //a and b are unordered

    //may add additional syntax for more complex partial ordering
    };
  };

  cpfs {
    time' = 
      if (search) then time + Poisson(5.5)
      else if (triageGreen) then time + 8
      else if (triageYellow) then time + 15
      else if (move) then time + Poisson(5.6)
      else time;

    num_of_yellow_victims_found_in_adj_room' = 
      if (search ^ (time < YELLOW-DEATH-TIME)) 
        then num_of_yellow_victims_found_in_adj_room + Poisson(0.2/(1+times_searched))
      else if (move)
        then 0
      else num_of_yellow_victims_found_in_adj_room;

    num_of_green_victims_found_in_adj_room' = 
      if (search) 
        then num_of_green_victims_found_in_adj_room + Poisson(0.5/(1+times_searched))
      else if (move)
        then 0
      else num_of_green_victims_found_in_adj_room;

    times_searched' = 
      if (move)
        then 0
      else times_searched + search;

    num_of_yellow_victims_found_in_current_room' = 
      if (search ^ (time < YELLOW-DEATH-TIME)) 
        then num_of_yellow_victims_found_in_current_room + Poisson(1/(1+times_searched))
      else if (move)
        then 0
      else num_of_yellow_victims_found_in_current_room;

    num_of_green_victims_found_in_current_room' = 
      if (search) 
        then num_of_green_victims_found_in_current_room + Poisson(1.5/(1+times_searched))
      else if (move)
        then 0
      else num_of_green_victims_found_in_current_room;

    num_of_yellow_victims_triaged_in_current_room' = 
      if (move)
        then 0
      else num_of_yellow_victims_triaged_in_current_room + triageYellow;

    num_of_green_victims_triaged_in_current_room' = 
      if (move)
        then 0
      else num_of_green_victims_triaged_in_current_room + triageGreen;

    //The * signifies that this is to only be evaluated when needed. 
    YF(@search_YF)* = //Must return appropriate value type for YF 
        if (time >= END-GAME-TIME) 
          then 0
        else if (times_searched == 0)
          then 1
        else if (((num_of_yellow_victims_found_in_current_room - 
          num_of_yellow_victims_triaged_in_current_room) > 0) ^
            (time < YELLOW-DEATH-TIME - 15))
          then 0
        else if (((num_of_green_victims_found_in_current_room - 
          num_of_green_victims_triaged_in_current_room) > 0) ^
            (time >= YELLOW-DEATH-TIME - 15))
          then 0
        else if ((num_of_yellow_victims_found_in_adj_room > 0) ^
          (time < YELLOW-DEATH-TIME - 15))
          then 0
        else if ((num_of_green_victims_found_in_adj_room > 0) ^
          (time >= YELLOW-DEATH-TIME - 15))
          then 0
        else Bernoulli(1/(1+times_searched));



  };

  reward = (triageYellow * YELLOW-POINT-VALUE) + (triageGreen * GREEN-POINT-VALUE); 

  state-invariants {
    time >= 0;
    times_searched >= 0;
    num_of_yellow_victims_found_in_adj_room >= 0;
    num_of_green_victims_found_in_adj_room >= 0;
    num_of_yellow_victims_found_in_current_room >= 0;
    num_of_green_victims_found_in_current_room >= 0;
    num_of_yellow_victims_triaged_in_current_room >= 0;
    num_of_green_victims_triaged_in_current_room >= 0;
    num_of_yellow_victims_triaged_in_current_room
      <= num_of_yellow_victims_found_in_current_room;

    num_of_green_victims_triaged_in_current_room
      <= num_of_green_victims_found_in_current_room;


  };

  action-preconditions {
    ((num_of_yellow_victims_found_in_current_room -
      num_of_yellow_victims_triaged_in_current_room) == 0) 
        => ~triageYellow;

    ((num_of_green_victims_found_in_current_room -
      num_of_green_victims_triaged_in_current_room) == 0) 
        => ~triageGreen;

    (time < END-GAME-TIME) => ~exit;  
  };
}
